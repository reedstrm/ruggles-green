/*
 *  Copyright 2011 Google Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// html.soy - Build HTML from CNXML

{namespace org.cnx.cnxml.SoyHTMLGenerator}

/**
 *  Primary entry point for HTMLGenerator.  This template takes a CNXML DOM
 *  node and dispatches the rendering template.
 *
 *  @param node DOM node to render
 */
{template .main}
    {if $node.nodeType == 'text'}
        {$node.nodeValue}
    {elseif $node.nodeType == 'element'}
        {switch $node.localName}
            {case 'para'}
                {call .para data="all"/}
            {case 'section'}
                {call .section data="all"/}
            {case 'list'}
                {call .list data="all"/}
            {case 'link'}
                {call .link data="all"/}
            {case 'emphasis'}
                {call .emphasis data="all"/}
            {case 'foreign'}
                {call .foreign data="all"/}
            {case 'term'}
                {call .term data="all"/}
            {case 'sup'}
                {call .sup data="all"/}
            {case 'sub'}
                {call .sub data="all"/}
            {case 'newline'}
                {call .newline data="all"/}
            {case 'preformat'}
                {call .preformat data="all"/}
            {case 'code'}
                {call .code data="all"/}
            {case 'note'}
                {call .note data="all"/}
            {case 'media'}
                {call .media data="all"/}
            {case 'math'}
                {if $node.namespaceURI == 'http://www.w3.org/1998/Math/MathML'}
                    {call .math data="all"/}
                {/if}
            {case 'rule'}
                {call .rule data="all"/}
            {case 'statement'}
                {call .statement data="all"/}
            {case 'proof'}
                {call .proof data="all"/}
            {case 'example'}
                {call .example data="all"/}
            {case 'definition'}
                {call .definition data="all"/}
            {case 'exercise'}
                {call .exercise data="all"/}
            {case 'commentary'}
                {call .commentary data="all"/}
            {case 'problem'}
                {call .problem data="all"/}
            {case 'solution'}
                {call .solution data="all"/}
            {case 'equation'}
                {call .equation data="all"/}
            {case 'figure'}
                {call .figure data="all"/}
        {/switch}
    {elseif $node.nodeType == 'document'}
        {call .document}{param node: findElem($node, 'document')/}{/call}
    {/if}
{/template}

/**
 *  Render top-level document.
 *
 *  @param node DOM document node
 */
{template .document}
    {call .children}{param node: findElem($node, 'content')/}{/call}
{/template}

/**
 *  Render a para element.
 *
 *  @param node DOM element node
 */
{template .para}
    <p id="{$node.attributes.id}">{call .children data="all"/}</p>
{/template}

/**
 *  Render a section element.
 *
 *  @param node DOM element node
 */
{template .section}
    <section id="{$node.attributes.id}">
        {if findElem($node, 'title')}<h1>{innerText(findElem($node, 'title'))}</h1>{/if}
        {call .children data="all"/}
    </section>
{/template}

/**
 *  Render an emphasis element.
 *
 *  @param node DOM element node
 */
{template .emphasis}
    {switch $node.attributes.effect}
        {case 'italics'}
            {call .span}
                {param node: $node/}
                {param elemName: 'em'/}
            {/call}
        {case 'underline'}
            {call .span}
                {param node: $node/}
                {param elemName: 'u'/}
            {/call}
        {case 'smallcaps'}
            {call .span}
                {param node: $node/}
                {param className: 'smallcaps'/}
            {/call}
        {case 'normal'}
            {call .span}
                {param node: $node/}
                {param className: 'normal'/}
            {/call}
        {default}
            // Default to bold
            {call .span}
                {param node: $node/}
                {param elemName: 'strong'/}
            {/call}
    {/switch}
{/template}

/**
 *  Render the CNXML foreign element.
 *
 *  @param node DOM element node
 */
{template .foreign}
    <span class="foreign"{if $node.attributes.id} id="{$node.attributes.id}"{/if}>
        {call .maybeLink data="all"/}
    </span>
{/template}

/**
 *  Render the CNXML term element.
 *
 *  @param node DOM element node
 */
{template .term}
    <span class="term"{if $node.attributes.id} id="{$node.attributes.id}"{/if}>
        {call .maybeLink data="all"/}
    </span>
{/template}

/**
 *  Render the sup element.
 *
 *  @param node DOM element node
 */
{template .sup}
    {call .span}
        {param node: $node/}
        {param elemName: 'sup'/}
    {/call}
{/template}

/**
 *  Render the sub element.
 *
 *  @param node DOM element node
 */
{template .sub}
    {call .span}
        {param node: $node/}
        {param elemName: 'sub'/}
    {/call}
{/template}

/**
 *  Render the preformat element.
 *
 *  @param node DOM element node
 */
{template .preformat}
    {call .span}
        {param node: $node/}
        {param elemName: 'pre'/}
    {/call}
{/template}

/**
 *  Render the code element.
 *
 *  @param node DOM element node
 */
{template .code}
    {switch $node.attributes.display}
        {case 'none'}
            // render nothing
        {case 'block'}
            <pre>
                {call .span data="all"}
                    {param elemName: 'code'/}
                {/call}
            </pre>
        {default}
            {call .span data="all"}
                {param elemName: 'code'/}
            {/call}
    {/switch}
{/template}

/**
 *  Render the note element.
 *
 *  @param node DOM element node
 */
{template .note}
    {switch $node.attributes.display}
        {case 'none'}
            // render nothing
        {case 'inline'}
            {call .span data="all"}
                {param className: 'note'/}
            {/call}
        {default}
            <div class="note" id="{$node.attributes.id}">
                // TODO(light): Use proper heading levels
                <h2>
                    {if findElem($node, 'label')}
                        {innerText(findElem($node, 'label'))}
                    {else}
                        {switch $node.attributes.type}
                            {case 'aside'}
                                Aside
                            {case 'warning'}
                                Warning
                            {case 'tip'}
                                Tip
                            {case 'important'}
                                Important
                            {default}
                                Note
                        {/switch}
                    {/if}
                    :
                    {if findElem($node, 'title')}{sp}{innerText(findElem($node, 'title'))}{/if}
                </h2>
                {call .children data="all"/}
            </div>
    {/switch}
{/template}

/**
 *  Generic rendering of an inline element using a span or another element.
 *
 *  @param node CNXML DOM element node
 *  @param? elemName The element name to use (defaults to span)
 *  @param? className The class name to use.
 */
{template .span private="true"}
    <{if $elemName}{$elemName}{else}span{/if}
        {if $className}{sp}class="{$className}"{/if}
        {if $node.attributes.id}{sp}id="{$node.attributes.id}"{/if}
        >
        {call .children data="all"/}
    </{if $elemName}{$elemName}{else}span{/if}>
{/template}

/**
 *  Render a list element.
 *
 *  @param node DOM element node
 */
{template .list}
    {switch $node.attributes.display}
        {case 'none'}
            {if $node.attributes.list_type == 'enumerated'}
                {call .enumerated_list data="all"}{param hidden: true/}{/call}
            {else}
                {call .bulleted_list data="all"}{param hidden: true/}{/call}
            {/if}
        {case 'inline'}
            // TODO(light): inline lists
        {default}
            {if $node.attributes.list_type == 'enumerated'}
                {call .enumerated_list data="all"/}
            {else}
                {call .bulleted_list data="all"/}
            {/if}
    {/switch}
{/template}

/**
 *  Render a <list list-type="bulleted"> element.
 *
 *  @param node DOM element node
 *  @param? hidden Whether to hide element
 */
{template .bulleted_list private="true"}
    <ul id="{$node.attributes.id}"{if $hidden} style="display:none;"{/if}>
        {foreach $child in $node.childNodes}
            {if $child.localName == 'item'}
                {call .list_item}
                    {param node: $child/}
                    {param itemSep}
                        {if not isLast($child) and $node.attributes.item_sep}
                            {$node.attributes.item_sep}
                        {/if}
                    {/param}
                {/call}
            {/if}
        {/foreach}
    </ul>
{/template}

/**
 *  Render a <list list-type="enumerated"> element.
 *
 *  @param node DOM element node
 *  @param? hidden Whether to hide element
 */
{template .enumerated_list private="true"}
    <ol id="{$node.attributes.id}"
        {if $node.attributes.number_style}{sp}type="{$node.attributes.number_style}"{/if}
        {if $node.attributes.start_value}{sp}start="{$node.attributes.start_value}"{/if}
        {if $hidden}{sp}style="display:none;"{/if}
        >
        {foreach $child in $node.childNodes}
            {if $child.localName == 'item'}
                {call .list_item}
                    {param node: $child/}
                    {param itemSep}
                        {if not isLast($child) and $node.attributes.item_sep}
                            {$node.attributes.item_sep}
                        {/if}
                    {/param}
                {/call}
            {/if}
        {/foreach}
    </ol>
{/template}

/**
 *  Render an item element.
 *
 *  @param node DOM element node
 *  @param? itemSep Item separator to append
 */
{template .list_item private="true"}
    <li{if $node.attributes.id} id="{$node.attributes.id}"{/if}>
        {call .children data="all"/}
        {if $itemSep}{$itemSep}{/if}
    </li>
{/template}

/**
 *  Render a newline element.
 *
 *  @param node DOM element node
 */
{template .newline}
    // TODO(light): id is ignored
    {if $node.attributes.count}
        {call .newline_private}
            {param n: strtod($node.attributes.count)/}
            {param effect: $node.attributes.effect/}
        {/call}
    {else}
        {call .newline_private}
            {param n: 1/}
            {param effect: $node.attributes.effect/}
        {/call}
    {/if}
{/template}

/**
 *  Render a newline element.
 *
 *  @param n Number of newlines
 *  @param? effect Style of newline (either 'normal' or 'underline')
 */
{template .newline_private private="true"}
    {for $i in range($n)}
        {if $effect == 'underline'}
            <hr>
        {else}
            <br>
        {/if}
    {/for}
{/template}

/**
 *  Render a link element, or any CNXML element that has link attributes
 *  (e.g. foreign, term, etc.).  Note that this requires link attributes to be
 *  present; if the attributes are optional, then you should use .maybeLink.
 *
 *  @param node DOM element node
 */
{template .link}
    {if $node.attributes.url}
        <a href="{$node.attributes.url}">{call .children data="all"/}</a>
    {elseif $node.attributes.target_id and not $node.attributes.document}
        <a href="#{$node.attributes.target_id}">{call .children data="all"/}</a>
    {else}
        {call .children data="all"/}
    {/if}
{/template}

/**
 *  Render a link element, or any CNXML element that has link attributes
 *  (e.g. foreign, term, etc.).  If no link attributes are found, then the
 *  children of the node are rendered directly.
 *
 *  @param node DOM element node
 */
{template .maybeLink}
    {if $node.attributes.url or $node.attributes.document or $node.attributes.target_id or $node.attr.resource or $node.attr.version}
        {call .link data="all"/}
    {else}
        {call .children data="all"/}
    {/if}
{/template}

/**
 *  Render the media element.
 *
 *  @param node DOM element node
 */
{template .media}
    {call .media_dispatch}
        {param node: media($node)/}
        {param id: $node.attributes.id/}
        {param alt: $node.attributes.alt/}
    {/call}
{/template}

/**
 *  Dispatch the media child element.
 *
 *  @param node DOM element node for the media child.
 *  @param id Media ID
 *  @param alt Media alternate text
 */
{template .media_dispatch private="true"}
    {switch $node.localName}
        {case 'image'}
            {call .image data="all"/}
        {case 'object'}
            {call .object data="all"/}
    {/switch}
{/template}

/**
 *  Render an image inside a media tag.
 *
 *  @param id The id from <media>
 *  @param alt The alternate text from <media>
 *  @param node The image DOM element node
 */
{template .image private="true"}
    <img id="{$id}" alt="{$alt}" src="{$node.attributes.src}"
        {if $node.attributes.width}{sp}width="{$node.attributes.width}"{/if}
        {if $node.attributes.height}{sp}height="{$node.attributes.height}"{/if}>
{/template}

/**
 *  Render an object inside a media tag.
 *
 *  @param id The id from <media>
 *  @param alt The alternate text from <media>
 *  @param node The object DOM element node
 */
{template .object private="true"}
    <object id="{$id}" data="{$node.attributes.src}"
        {if $node.attributes.width}{sp}width="{$node.attributes.width}"{/if}
        {if $node.attributes.height}{sp}height="{$node.attributes.height}"{/if}>
        {if $alt}{$alt}{/if}
    </object>
{/template}

/**
 *  Render all the children of a parent using .main.
 *
 *  @param node Parent DOM node
 */
{template .children private="true"}
    {foreach $child in $node.childNodes}{call .main}{param node: $child/}{/call}{/foreach}
{/template}

/**
 *  Render m:math XML element and its descendants.
 *
 *  As per the HTML5 specification, there is no namespacing in the output.
 *  http://dev.w3.org/html5/spec/the-map-element.html#mathml
 *
 *  @param node DOM node matching a <m:math> element.
 */
{template .math}
    <math>{call .mathChildren data="all"/}</math>
{/template}

/**
 *  Copy children of a MathML element.
 *
 *  Don't use .main for this purpose, because .main is expecting CNXML.
 *
 *  @param node DOM node for a MathML element
 */
{template .mathChildren}
    {foreach $child in $node.childNodes}
        {if $child.nodeType == 'text'}
            {$child.nodeValue}
        {elseif $child.nodeType == 'element'}
            <{$child.localName}{call .mathAttributes}{param node: $child/}{/call}>
                {call .mathChildren}{param node: $child/}{/call}
            </{$child.localName}>
        {/if}
    {/foreach}
{/template}

/**
 *  Copy attributes of a MathML element.
 *
 *  @param node DOM node for a MathML element
 */
{template .mathAttributes}
    {foreach $attr in $node.attributeNodes}
        {sp}{$attr.localName}="{$attr.nodeValue}"
    {/foreach}
{/template}

/**
 *  Render a rule element.
 *
 *  @param node DOM element node
 */
{template .rule}
    {call .numbered data="all"}
        {param class: 'rule'/}
        {param label}
            {if findElem($node, 'label')}
                {innerText(findElem($node, 'label'))}
            {else}
                {switch $node.attributes.type}
                    {case 'theorem'}
                        Theorem
                    {case 'lemma'}
                        Lemma
                    {case 'corollary'}
                        Corollary
                    {case 'law'}
                        Law
                    {case 'proposition'}
                        Proposition
                    {default}
                        Rule
                {/switch}
            {/if}
        {/param}
    {/call}
{/template}

/**
 *  Render a statement element.
 *
 *  @param node DOM element node
 */
{template .statement}
    {call .span data="all"}
        {param elemName: 'div'/}
        {param className: 'statement'/}
    {/call}
{/template}

/**
 *  Render a proof element.
 *
 *  @param node DOM element node
 */
{template .proof}
    <div class="proof"{if $node.attributes.id} id="{$node.attributes.id}"{/if}>
        // TODO(light): Heading depth
        <h2>Proof</h2>
        {call .children data="all"/}
    </div>
{/template}

/**
 *  Render an example element.
 *
 *  @param node DOM element node
 */
{template .example}
    {call .numbered data="all"}
        {param class: 'example'/}
        {param label}
            {if findElem($node, 'label')}
                {innerText(findElem($node, 'label'))}
            {else}
                Example
            {/if}
        {/param}
    {/call}
{/template}

/**
 *  Render a definition element.
 *
 *  @param node DOM element node
 */
{template .definition}
    <div class="definition"{if $node.attributes.id} id="{$node.attributes.id}"{/if}>
        // TODO(light): Use proper heading levels
        <h2>
            {if findElem($node, 'label')}
                {innerText(findElem($node, 'label'))}
            {else}
                Definition
            {/if}
            {sp}{$node.number}
            {if findElem($node, 'term')}: {innerText(findElem($node, 'term'))}{/if}
        </h2>
        <ol>
        // TODO(light): Allow interspersed examples with meanings
        {foreach $child in $node.childNodes}
            {if $child.localName == 'meaning'}
                {call .span}
                    {param node: $child/}
                    {param elemName: 'li'/}
                    {param className: 'meaning'/}
                {/call}
            {/if}
        {/foreach}
        </ol>
    </div>
{/template}

/**
 *  Render an exercise element.
 *
 *  @param node DOM element node
 */
{template .exercise}
    {call .numbered data="all"}
        {param class: 'exercise'/}
        {param label}
            {if findElem($node, 'label')}
                {innerText(findElem($node, 'label'))}
            {else}
                Exercise
            {/if}
        {/param}
    {/call}
{/template}

/**
 *  Render a commentary element.
 *
 *  @param node DOM element node
 */
{template .commentary}
    {call .span data="all"}
        {param elemName: 'div'/}
        {param className: 'commentary'/}
    {/call}
{/template}

/**
 *  Render a problem element.
 *
 *  @param node DOM element node
 */
{template .problem}
    {call .span data="all"}
        {param elemName: 'div'/}
        {param className: 'problem'/}
    {/call}
{/template}

/**
 *  Render a solution element.
 *
 *  @param node DOM element node
 */
{template .solution}
    {call .span data="all"}
        {param elemName: 'div'/}
        {param className: 'solution'/}
    {/call}
{/template}

/**
 *  Render an equation element.
 *
 *  @param node DOM element node
 */
{template .equation}
    {call .numbered data="all"}
        {param class: 'equation'/}
        {param label}
            {if findElem($node, 'label')}
                {innerText(findElem($node, 'label'))}
            {else}
                Equation
            {/if}
        {/param}
    {/call}
{/template}

/**
 *  Render a figure element.
 *
 *  @param node DOM element node
 */
{template .figure}
    {if findElem($node, 'title')}
        // TODO(light): Use proper heading levels
        <h3>{innerText(findElem($node, 'title'))}</h3>
    {/if}

    <figure id="{$node.attributes.id}">
        {if findElem($node, 'subfigure')}
            {if $node.attributes.orient == 'vertical'}
                {call .verticalSubfigures data="all"/}
            {else}
                {call .horizontalSubfigures data="all"/}
            {/if}
        {else}
            {call .children data="all"/}
        {/if}
        <figcaption>
            {if findElem($node, 'label')}
                {innerText(findElem($node, 'label'))}
            {else}
                Figure
            {/if}
            {sp}{$node.number}
            {if findElem($node, 'caption')}: {innerText(findElem($node, 'caption'))}{/if}
        </figcaption>
    </figure>
{/template}

/**
 *  Show subfigures in a vertical configuration.
 *
 *  @param node The figure DOM element node
 */
{template .verticalSubfigures private="true"}
    <table class="verticalSubfigureContainer">
        <tbody>
            {foreach $child in $node.childNodes}
                {if $child.nodeType == 'element' and $child.localName == 'subfigure'}
                    <tr><td>{call .children}{param node: $child/}{/call}</tr></td>
                {/if}
            {/foreach}
        </tbody>
    </table>
{/template}

/**
 *  Show subfigures in a horizontal configuration.
 *
 *  @param node The figure DOM element node
 */
{template .horizontalSubfigures private="true"}
    <table class="horizontalSubfigureContainer">
        <tbody>
            <tr>
                {foreach $child in $node.childNodes}
                    {if $child.nodeType == 'element' and $child.localName == 'subfigure'}
                        <td>{call .children}{param node: $child/}{/call}</td>
                    {/if}
                {/foreach}
            </tr>
        </tbody>
    </table>
{/template}

/**
 *  Render a numbered group.
 *
 *  @param node DOM node
 *  @param class CSS class to apply to the generated div
 *  @param label Label for this type
 */
{template .numbered private="true"}
    <div class="{$class}"{if $node.attributes.id} id="{$node.attributes.id}"{/if}>
        // TODO(light): Use proper heading levels
        <h2>
            {$label} {$node.number}
            {if findElem($node, 'title')}: {innerText(findElem($node, 'title'))}{/if}
        </h2>
        {call .children data="all"/}
    </div>
{/template}
